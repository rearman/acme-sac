#
#	initially generated by c2l
#

implement History;

include "draw.m";
include "sys.m";
	sys: Sys;
	Dir: import sys;
include "libc.m";
	libc: Libc;
include "math.m";
	math: Math;
include "daytime.m";
	daytime: Daytime;
	Tm, gmt, local, text, now: import daytime;
include "workdir.m";
	workdir: Workdir;
include "arg.m";
include "sh.m";

History: module
{
	init: fn(nil: ref Draw->Context, argl: list of string);
};

verb, uflag, diff, diffb: int;
ndump, sflag: string;
stderr: ref Sys->FD;

init(nil: ref Draw->Context, argv: list of string)
{
	sys = load Sys Sys->PATH;
	libc = load Libc Libc->PATH;
	math = load Math Math->PATH;
	daytime = load Daytime Daytime->PATH;
	workdir = load Workdir Workdir->PATH;

	stderr = sys->fildes(2);
	ndump = "dump";
	arg := load Arg Arg->PATH;
	arg->init(argv);
	while((o := arg->opt()) != 0){
		case o {
		* =>
			;	# TBA was goto usage
		'v' =>
			verb = 1;
		'd' =>
			ndump = arg->arg();
		'D' =>
			diff = 1;
		'b' =>
			diffb = 1;
		's' =>
			sflag = arg->arg();
		'u' =>
			uflag = 1;
		}
	}
	argv = arg->argv();
	if(len argv == 0){
		sys->fprint(sys->fildes(2), "usage: history [-vuD] [-d 9fsname] [-s yymmdd] files\n");
		exit;
	}
	for(; argv != nil; argv = tl argv)
		ysearch(hd argv);
	exit;
}

ysearch(file: string)
{
	fil, buf : string;
	pair := array[2] of string;
	dir: Dir;
	otime, dt: int;
	toggle, started: int;
	err: int;

	if(file[0] !=  '/'){
		fil = workdir->init();
		fil += "/";
	}
	fil += file;
	started = 0;
	tm := local(now());
	buf = sys->sprint("/n/%s/%.4d/", ndump, tm.year+1900);
	(err, dir) = sys->stat(buf);
	if(err){
		if(verb)
			sys->print("not mounting dump\n");
		exit;
	}
	(err, dir) = sys->stat(file);
	if(err)
		sys->fprint(sys->fildes(2), "history: warning: %s does not exist\n", file);
	else{
		sys->print("%s %s %bd\n", prtime(dir.mtime), file, dir.length);
		started = 1;
		pair[1] = file;
	}
	dir.mtime = starttime(sflag);
	toggle = 0;
	for(;;){
		otime = dir.mtime;
		buf = lastbefore(otime, fil);
		sys->print("%s\n", buf);
		(err, dir) = sys->stat(buf);
		if(err)
			return;
		dt = 12*60*60;
		while(otime <= dir.mtime){
			if(verb)
				sys->print("backup %d, %d\n", dir.mtime, otime-dt);
			buf = lastbefore(otime-dt, fil);
			(err, dir) = sys->stat(buf);
			if(err)
				return;
			dt += 12*60*60;
		}
		pair[toggle] = buf;
		if(diff && started){
			if(diffb)
				execl("/dis/diff.dis", "diff" :: "-b" :: pair[toggle^1] :: pair[toggle] :: nil);
			else
				execl("/dis/diff.dis", "diff" ::  pair[toggle^1] :: pair[toggle] :: nil);
		}
		sys->print("%s %s %bd\n", prtime(dir.mtime), buf, dir.length);
		toggle ^= 1;
		started = 1;
	}
}

lastbefore(t: int, f: string): string
{
	tm: ref Tm;
	dir: Dir;
	vers, try: int;
	t0: int;
	b: string;
	e: int;

	t0 = t;
	if(verb)
		sys->print("%d lastbefore %s\n", t0, f);
	for(try = 0; try < 10; try++){
		tm = local(t);
		b = sys->sprint("/n/%s/%.4d/%.2d%.2d", ndump, tm.year+1900, tm.mon+1, tm.mday);
		(e, dir) = sys->stat(b);
		if(e || dir.mtime > t0){
			if(verb)
				sys->print("%d earlier %s\n", dir.mtime, b);
			t -= 24*60*60;
			continue;
		}
		for(vers = 0;; vers++){
			b = sys->sprint("/n/%s/%.4d/%.2d%.2d%d", ndump, tm.year+1900, tm.mon+1, tm.mday, vers+1);
			(e, dir) = sys->stat(b);
			if(e || dir.mtime > t0)
				break;
			if(verb)
				sys->print("%d later %s\n", dir.mtime, b);
		}
		b = sys->sprint("/n/%s/%.4d/%.2d%.2d%s", ndump, tm.year+1900, tm.mon+1, tm.mday, f);
		if(vers)
			b = sys->sprint("/n/%s/%.4d/%.2d%.2d%d%s", ndump, tm.year+1900, tm.mon+1, tm.mday, vers, f);
		return b;
	}
	b = "XXX";
	return b;
}


prtime(t: int): string
{
	b: string;
	tm: ref Tm;

	if(uflag)
		tm = gmt(t);
	else
		tm = local(t);
	b = text(tm);
	buf := b[4:24];
	return buf;
}

starttime(s: string): int
{
	tm: ref Tm;
	t, dt: int;
	i, yr, mo, da: int;

	t = now();
	if(s == nil)
		return t;
	for(i = 0; i < 6; i++)
		if(s[i] <  '0' || s[i] >  '9'){
			sys->fprint(sys->fildes(2), "bad start time: %s\n", s);
			return t;
		}
	yr = (int s[0]-'0')*10+int s[1]-'0';
	mo = (int s[2]-'0')*10+int s[3]-'0'-1;
	da = (int s[4]-'0')*10+int s[5]-'0';
	t = 0;
	dt = 10*60*60*24*360;
	for(i = 0; i < 50; i++){
		tm = local(t+dt);
		if(yr > tm.year || yr == tm.year && mo > tm.mon || yr == tm.year && mo == tm.mon && da > tm.mday){
			t += dt;
			continue;
		}
		dt /= 2;
		if(dt == 0)
			break;
	}
	t += 12*60*60;	#  .5 day to get to noon of argument 
	return t;
}

child(file: string, args: list of string, pidc: chan of int)
{
	pidc <-= sys->pctl(Sys->NEWFD|Sys->FORKNS|Sys->NEWPGRP, list of {0, 1, 2});
	cmd := load Command file;
	if(cmd == nil){
		sys->print("can't load %s: %r\n", file);
		exit;
	}
	cmd->init(nil, args);
}

waitfd: ref Sys->FD;

execl(disfile: string, args: list of string)
{
	waitfd = sys->open("#p/"+string sys->pctl(0, nil)+"/wait", sys->OREAD);
	if(waitfd == nil){
		sys->fprint(stderr, "time: open wait: %r\n");
		return;
	}
	pidc := chan of int;
	spawn child(disfile, args, pidc);
	waitfor(<-pidc);
}

waitfor(pid: int)
{
	buf := array[sys->WAITLEN] of byte;
	status := "";
	for(;;){
		n := sys->read(waitfd, buf, len buf);
		if(n < 0) {
			sys->fprint(stderr, "sh: read wait: %r\n");
			return;
		}
		status = string buf[0:n];
	#	if(status[len status-1] != ':')
	#		sys->fprint(stderr, "%s\n", status);
		who := int status;
		if(who != 0) {
			if(who == pid)
				return;
		}
	}
}
