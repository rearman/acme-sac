#
#	initially generated by c2l
#	original C version lifted from Russ Cox's website
#	http://www.eecs.harvard.edu/~rsc/plan9.html
#

implement Localcron;

include "draw.m";

include "sys.m";
	sys: Sys;
	Qid, Dir : import sys;
include "math.m";
	math: Math;
include "daytime.m";
	daytime: Daytime;
	Tm: import daytime;
include "bufio.m";
	bufio: Bufio;
	Iobuf: import bufio;
include "arg.m";
	arg: Arg;
include "sh.m";
	sh: Command;
	

Localcron: module
{
	init: fn(nil: ref Draw->Context, argl: list of string);
};

CRONLOG := "cron";

Time: adt{	#  bit masks for each valid time 
	min: int;	#  actually 1 bit for every 2 min 
	hour: int;
	mday: int;
	wday: int;
	mon: int;
};

Job: adt{
	host: string;	#  where ... 
	time: Time;	#  when ... 
	cmd: string;	#  and what to execute 
};

User: adt{
	lastqid: Qid;	#  of last read /cron/user/cron 
	name: string;	#  who ... 
	jobs: list of ref Job;	#  wants to execute these jobs 
};

me: User;
savec, savetok: string;
tok, debug: int;
lexval: int;

init(nil: ref Draw->Context, argl: list of string)
{
	sys = load Sys Sys->PATH;
	math = load Math Math->PATH;
	daytime = load Daytime Daytime->PATH;
	bufio = load Bufio Bufio->PATH;
	arg = load Arg Arg->PATH;

	tm: ref Tm;
	t: Time;
	now, last, x: int;

	debug = 0;
	arg->init(argl);
	while((c := arg->opt()) != 0) {
		case c{
		'd' =>
			debug = 1;
		* =>
			usage();
		}
	}
	argl = arg->argv();
	if(debug){
		readalljobs();
		printjobs();
		exit;
	}
	last = daytime->now()/60;
	for(;;){
		readalljobs();
		now = daytime->now()/60;
		for(; last <= now; last += 2){
			tm = daytime->local(last*60);
			t.min = 1<<tm.min/2;
			t.hour = 1<<tm.hour;
			t.wday = 1<<tm.wday;
			t.mday = 1<<tm.mday;
			t.mon = 1<<tm.mon+1;
			for(jl := me.jobs; jl != nil; jl = tl jl){
				j := hd jl;
				if(j.time.min&t.min 
				&& j.time.hour&t.hour 
				&& j.time.wday&t.wday 
				&& j.time.mday&t.mday 
				&& j.time.mon&t.mon)
					spawn rexec(ref me, j);
			}
		}
		x = daytime->now()/60;
		if(x-now < 2)
			sys->sleep((2-(x-now))*60*1000);
	}
	exit;
}

readalljobs()
{
	file: string;

	if(me.name == nil){
		me.name = getuser();
		me.lastqid = Qid(big -1, -1, -1); 
		me.jobs = nil;
	}
	file = sys->sprint("/cron/%s/cron", me.name);
	(n, db) := sys->stat(file);
	if(n < 0)
		return;
	if(qidcmp(me.lastqid, db.qid) != 0){
		me.jobs = readjobs(file, ref me);
	}
}

#
# parse user's cron file
# other lines: minute hour monthday month weekday host command
#
readjobs(file: string, user: ref User): list of ref Job
{
	j:  ref Job;
	jobs: list of ref Job;
	d: Dir;
	line, n: int;

	b := bufio->open(file, Sys->OREAD);
	if(b == nil)
		return nil;
	(n, d) = sys->stat(file);
	user.lastqid = d.qid;
	jobs = nil;
	for(line = 1; (savec = b.gets('\n')) != nil; line++){
		savec = savec[0:(len savec -1 )];
		while(savec[0] == ' ' || savec[0] == '\t')
			savec = savec[1:];
		if(savec == "" || savec[0] ==  '#' )
			continue;
		j =  ref Job;
		if((j.time.min = gettime(0, 59)) 
		&& (j.time.hour = gettime(0, 23)) 
		&& (j.time.mday = gettime(1, 31)) 
		&& (j.time.mon = gettime(1, 12)) 
		&& (j.time.wday = gettime(0, 6)) 
		&& ((j.host = getname()) != nil)){
			j.cmd = savec;
			jobs = j :: jobs;
		}else{
			j = nil;
		}
	}
	return jobs;
}

printjobs()
{
	sys->print("user %s\n", me.name);
	for(jl := me.jobs; jl!= nil; jl = tl jl)
		sys->print("\tjob %s on host %s\n", (hd jl).cmd, (hd jl).host);
}

getname(): string
{
	c, i: int;
	name: string;

	if(savec == nil)
		return nil;
	while(savec[0] == int ' ' || savec[0] == int '\t')
		savec = savec[1:];
	for(i = 0; (c = int savec[i]) && c != int ' ' && c != int '\t'; i++)
		;
	name = savec[0:i];
	savec = savec[i:];
	while(savec[0] == int  ' ' || savec[0] == int  '\t')
		savec = savec[1:];
	return name;
}

# 
#  * return the next time range in the file:
#  * times: '*'
#  * 	| range
#  * range: number
#  *	| number '-' number
#  *	| range ',' range
#  * a return of zero means a syntax error was discovered
#  
gettime(min: int, max: int): int
{
	n, m, e: int;

	if(gettok(min, max) == '*')
		return ~0;
	n = 0;
	while(tok == '1'){
		m = 1<<lexval;
		n |= m;
		if(gettok(0, 0) == '-'){
			if(gettok(lexval, max) != '1')
				return 0;
			e = 1<<lexval;
			for(; m <= e; m <<= 1)
				n |= m;
			gettok(min, max);
		}
		if(tok != ',')
			break;
		if(gettok(min, max) != '1')
			return 0;
	}
	pushtok();
	return n;
}

pushtok()
{
	savec = savetok;
}

gettok(min: int, max: int): int
{
	c: int;
	i: int;
	savetok = savec;
	if(savec == nil)
		return tok = 0;
	while((c = savec[0]) == int ' ' || c == int '\t')
		savec = savec[1:];
	case(int c){
	'0' or '1' or '2' or '3' or '4' or '5' or '6' or '7' or '8' or '9' =>
			for(i = 0; (c = int savec[i]) && c >= int '0' && c <= int '9'; i++)
				;
		lexval = int savec[0:i];
		savec = savec[i:];
		if(lexval < min || lexval > max)
			return tok = 0;
		if(max > 32)
			lexval /= 2;	#  yuk: correct min by / 2 
		return tok = '1';
	'*' or '-' or ',' =>
		savec = savec[1:];
		return tok = int c;
	* =>
		return tok = 0;
	}
}

rexec(nil: ref User, j: ref Job)
{
	sys->pctl(Sys->NEWFD|Sys->FORKNS|Sys->NEWPGRP, list of {0, 1, 2});
	sh = load Command "/dis/sh.dis";

	if(j.host != "local")
		return;
#	fd := sys->open("/dev/null", Sys->ORDWR);
#	sys->dup(fd, 0);
#	sys->dup(fd, 1);
#	sys->dup(fd, 2);
	sh->init(nil, "sh" :: "-c" :: j.cmd :: nil);
}

usage()
{
	sys->fprint(sys->fildes(2), "usage: cron [-c]\n");
	exit;
}

qidcmp(a: Qid, b: Qid): int
{
	#  might be useful to know if a > b, but not for cron 
	return a.path != b.path || a.vers != b.vers;
}

getuser(): string
{
	fd := sys->open("/dev/user", sys->OREAD);
	if(fd == nil){
		sys->fprint(sys->fildes(2), "cron: cannot open /dev/user: %r\n");
		raise "fail:no user id";
	}

	buf := array[50] of byte;
	n := sys->read(fd, buf, len buf);
	if(n < 0){
		sys->fprint(sys->fildes(2), "cron: cannot read /dev/user: %r\n");
		raise "fail:no user id";
	}

	return string buf[0:n];	
}

error(fmt: string)
{
	sys->fprint(sys->fildes(2), "%s", fmt);
	exit;
}

